# Función principal que devuelve todas las soluciones del problema N reinas
def nreinas2_todas(N, A):
    """
    Args:
        N: Tamaño del tablero (1 ≤ N ≤ 8)
        A: Lista de listas, donde A[i] contiene filas bloqueadas en la columna i.
    
    Returns:
        Lista de soluciones, donde cada solución es una lista P con
        P[i] indicando la fila de la reina en la columna i.
    """
    
    # Función que verifica que no haya conflictos de reinas
    def no_conflictos(tablero, actual):
        """
        Args:
            tablero: lista con la posición de las reinas hasta la columna 'actual'
            actual: columna actual que se está evaluando
        
        Returns:
            True si no hay conflicto con reinas ya colocadas, False si hay conflicto
        """
        for i in range(actual):
            # Misma fila
            if tablero[i] == tablero[actual]:
                return False
            # Misma diagonal
            if abs(tablero[actual]-tablero[i]) == abs(actual-i):
                return False
        return True

    # Función DFS recursiva que construye todas las soluciones
    def dfs(tablero, actual, soluciones):
        """
        Args:
            tablero: lista temporal de posiciones de reinas
            actual: columna actual donde colocar la reina
            soluciones: lista donde se almacenan todas las soluciones
        """
        # Caso base: si se colocaron reinas en todas las columnas
        if actual == N:
            soluciones.append(tablero.copy())  # Guardar copia de la solución
            return
        
        # Intentar colocar la reina en cada fila de la columna actual
        for fila in range(N):
            # Saltar si la fila está bloqueada en esta columna
            if fila in A[actual]:
                continue
            tablero[actual] = fila  # Colocar temporalmente la reina
            if no_conflictos(tablero, actual):
                dfs(tablero, actual+1, soluciones)  # Continuar con la siguiente columna

    tablero = [-1]*N  # Inicializar tablero sin reinas
    soluciones = []   # Lista para almacenar todas las soluciones
    dfs(tablero, 0, soluciones)  # Iniciar DFS desde la columna 0
    return soluciones  # Devolver todas las soluciones encontradas


# Función para imprimir el tablero con restricciones
def imprimir_tablero_restringido(solucion, A):
    """
    Imprime el tablero mostrando:
      - 'Q' para la reina
      - 'X' para filas bloqueadas
      - '.' para posiciones libres
    Args:
        solucion: Lista con la posición de la reina en cada columna
        A: Lista de listas con filas bloqueadas por columna
    """
    N = len(solucion)
    print("Solución:", solucion)
    print("   " + " ".join(str(i) for i in range(N)))  # Encabezado de columnas
    
    # Imprimir cada fila del tablero
    for fila in range(N):
        fila_tablero = []
        for col in range(N):
            if fila in A[col]:
                fila_tablero.append("X")  # Posición bloqueada
            elif solucion[col] == fila:
                fila_tablero.append("Q")  # Reina
            else:
                fila_tablero.append(".")  # Libre
        print(f"{fila}: " + " ".join(fila_tablero))
    print("\n")


# === EJEMPLO DE USO ===
N = int(input("Introduce el tamaño del tablero (1 ≤ N ≤ 8): "))

# Inicializar lista de listas vacías para restricciones por columna
A = [[] for _ in range(N)]

print("Introduce filas bloqueadas por columna o deja vacío si no hay bloqueo:")
for i in range(N):
    filas = input(f"Columna {i}: ")
    if filas.strip() != "":
        # Convertir la entrada en enteros y filtrar fuera de rango
        A[i] = [int(x.strip()) for x in filas.split(",") if 0 <= int(x.strip()) < N]

# Obtener todas las soluciones posibles
soluciones = nreinas2_todas(N, A)

# Imprimir resultados
if not soluciones:
    print("No hay soluciones")
else:
    print(f"Se encontraron {len(soluciones)} soluciones.\n")
    for sol in soluciones:
        imprimir_tablero_restringido(sol, A)


